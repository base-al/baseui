package {{.PackageName}}

import (
    "errors"
    "math"

    "gorm.io/gorm"
    "gorm.io/gorm/clause"
    "base/app/models"
    "base/core/types"
)

type {{.StructName}}Service struct {
    DB *gorm.DB
}

func New{{.StructName}}Service(db *gorm.DB) *{{.StructName}}Service {
    return &{{.StructName}}Service{
        DB: db,
    }
}

func (s *{{.StructName}}Service) Create(req *models.Create{{.StructName}}Request) (*models.{{.StructName}}, error) {
    item := models.{{.StructName}}{
        {{- range .Fields}}
        {{- if or (eq .Relationship "belongs_to") (eq .Relationship "belongsTo")}}
        {{.Name}}ID: req.{{.Name}}ID,
        {{- else if or (eq .Relationship "has_one") (eq .Relationship "hasOne")}}
        {{.Name}}: req.{{.Name}},
        {{- else if ne .Relationship "has_many"}}
        {{.Name}}: req.{{.Name}},
        {{- end}}
        {{- end}}
    }
    if err := s.DB.Create(&item).Error; err != nil {
        return nil, err
    }
    return s.GetByID(item.ID)
}

func (s *{{.StructName}}Service) Update(id uint, req *models.Update{{.StructName}}Request) (*models.{{.StructName}}, error) {
    item, err := s.GetByID(id)
    if err != nil {
        return nil, err
    }
    {{- range .Fields}}
    {{- if or (eq .Relationship "belongs_to") (eq .Relationship "belongsTo")}}
    if req.{{.Name}}ID != nil {
        item.{{.Name}}ID = *req.{{.Name}}ID
    }
    {{- else if or (eq .Relationship "has_one") (eq .Relationship "hasOne")}}
    if req.{{.Name}} != nil {
        item.{{.Name}} = *req.{{.Name}}
    }
    {{- else if ne .Relationship "has_many"}}
    if req.{{.Name}} != nil {
        item.{{.Name}} = *req.{{.Name}}
    }
    {{- end}}
    {{- end}}
    if err := s.DB.Save(item).Error; err != nil {
        return nil, err
    }
    return s.GetByID(id)
}

func (s *{{.StructName}}Service) GetByID(id uint) (*models.{{.StructName}}, error) {
    var item models.{{.StructName}}
    if err := s.DB.Preload(clause.Associations).First(&item, id).Error; err != nil {
        return nil, err
    }
    return &item, nil
}

func (s *{{.StructName}}Service) GetAll(page *int, limit *int) (*types.PaginatedResponse, error) {
    if page != nil && limit != nil {
        var items []*models.{{.StructName}}
        paginatedResponse, err := paginate(s.DB, *page, *limit, &items)
        if err != nil {
            return nil, err
        }
        return &paginatedResponse, nil
    }

    var allItems []*models.{{.StructName}}
    if err := s.DB.Preload(clause.Associations).Find(&allItems).Error; err != nil {
        return nil, err
    }

    response := types.PaginatedResponse{
        Data: allItems,
        Pagination: types.Pagination{
            Total:      int64(len(allItems)),
            Page:       1,
            PageSize:   len(allItems),
            TotalPages: 1,
        },
    }

    return &response, nil
}

func (s *{{.StructName}}Service) Delete(id uint) error {
    result := s.DB.Delete(&models.{{.StructName}}{}, id)
    if result.Error != nil {
        return result.Error
    }
    if result.RowsAffected == 0 {
        return errors.New("item not found")
    }
    return nil
}

func (s *{{.StructName}}Service) GetAssociated(id uint, associationName string) (interface{}, error) {
    item, err := s.GetByID(id)
    if err != nil {
        return nil, err
    }

    var associated interface{}
    if err := s.DB.Model(item).Association(associationName).Find(&associated); err != nil {
        return nil, err
    }

    return associated, nil
}

func paginate(db *gorm.DB, page, limit int, out interface{}) (types.PaginatedResponse, error) {
    var total int64
    if err := db.Model(&models.{{.StructName}}{}).Count(&total).Error; err != nil {
        return types.PaginatedResponse{}, err
    }

    totalPages := int(math.Ceil(float64(total) / float64(limit)))
    offset := (page - 1) * limit

    if err := db.Preload(clause.Associations).Limit(limit).Offset(offset).Find(out).Error; err != nil {
        return types.PaginatedResponse{}, err
    }

    pagination := types.Pagination{
        Total:      total,
        Page:       page,
        PageSize:   limit,
        TotalPages: totalPages,
    }

    return types.PaginatedResponse{
        Data:       out,
        Pagination: pagination,
    }, nil
}
